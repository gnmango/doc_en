Let's make an item go to the inventory when it is purchased from the store.
One inventory slot can contain up to 10 items. When the maximum number of items is reached, the next item will be stored in the next slot. For example, if you already have 5 Red Potions in the inventory and buy 10 more, the first 5 potions will be stored in the same slot where the 5 potions are, and the next 5 potions will be stored in the new slot.

# Create SimpleInventoryItemAddedEvent
1. Select **Workspace - MyDesk - Create Scripts - Create EventType** to create a new SimpleInventoryItemAddedEvent.
2. Add the property. 

    ```lua
    Property:
    integer SlotIndex = 0
    string ItemId = ""
    integer ItemCount = 0
    ```
    
# Create SimpleInventoryItemModifiedEvent

1. Select **Workspace - MyDesk - Create Scripts - Create EventType** to create the SimpleInventoryItemModifiedEvent.
2. Add the property.

    ```lua
    Property:
    integer SlotIndex = 0
    string ItemId = ""
    integer ItemCount = 0
    ```
    
# Create SimpleInventoryItemRemovedEvent
1. Select **Workspace - MyDesk - Create Scripts - Create EventType** to create a new SimpleInventoryItemRemovedEvent.
2. Add the property. 

    ```lua
    Property:
    integer SlotIndex = 0
    string ItemId = ""
    ```
    
# Create SimpleInventoryMesoModifiedEvent

1. Select **Workspace - MyDesk - Create Scripts - Create EventType** to create the SimpleInventoryMesoModifiedEvent.
2. Add the property.

    ```lua
    Property:
    integer Meso = 0
    ```    

# Adding Items
Let's add the SimpleInventory component items to the inventory.

1. Add the **Capacity** property.

    ```lua
    [None]
    integer Capacity = 16
    ```

2. Add the new integer-type AddItem() function. Add **itemId** and **itemCount** parameters. Write it to add items to the inventory. The AddItem() function works as follows:

    * Put the item corresponding to the **itemId** in the inventory by **itemCount**.
    * If the maximum number of items for the slot in the inventory is not reached, fill it with items. After that, put the remaining items in a new slot.
    * Return 0 if all items are contained in the inventory.
    * Return the number of remaining items if there are no inventory slots available to contain them.
    * A single slot can't contain more than **MaxStackCount**.
    *  Generate **ItemModifiedEvent** and **ItemAddedEvent**.

    ```lua
    [server only]
    integer AddItem (string itemId, integer itemCount)
    {
        local itemInfo = _Data.ItemTable[itemId]
        
        if itemInfo == nil then
        	log_error("[SimpleInventory] (AddItem) Item Id Error: " .. itemId)
        	return
        end
        
        if itemCount <= 0 then
        	log_error("[SimpleInventory] (AddItem) Item Count Error: " .. itemCount)
        	return
        end
        
        local maxStackCount = itemInfo.MaxStackCount
        local remain = itemCount
        
        -- Fill an existing slot with items
        for i = 1, self.Capacity do
        	if remain <= 0 then
        		break
        	end
        	
        	---@type ItemStack
        	local stack = self.ItemStacks[i]
        	
        	if stack == nil then
        		continue
        	end
        	
        	if stack.ItemId == itemId then
        		local addCount = math.min(maxStackCount - stack.Count, remain)
        		stack.Count = stack.Count + addCount
        		remain = remain - addCount
        		
        	end
        end
        
        -- Create the new slot to fill the remaining items
        for i = 1, self.Capacity do
        	if remain <= 0 then
        		break
        	end
        	
        	if self.ItemStacks[i] ~= nil then
        		continue
        	end
        	
        	local addCount = math.min(maxStackCount, remain)
        		
        	local newStack = ItemStack()
        	newStack.SlotIndex = i
        	newStack.ItemId = itemId
        	newStack.Count = addCount
        	self.ItemStacks[i] = newStack
        		
        	remain = remain - addCount
        end
        
        -- Fill all and return the remaining count
        return remain
    }
    ```

3. Create the SendItemAddedEventToClient() function. Set the parameter type to **EventType - SimpleInventoryAddedEvent** and add the **event** parameter.

    ```lua
    [client]
    void SendItemAddedEventToClient (SimpleInventoryItemAddedEvent event)
    {
        local stack = ItemStack()
        stack.SlotIndex = event.SlotIndex
        stack.ItemId = event.ItemId
        stack.Count = event.ItemCount
        self.ItemStacks[event.SlotIndex] = stack
        
        self.Entity:SendEvent(event)
    }
    ```

4. Create the SendItemAddedEvent() function. Set the parameter type to **StructType - ItemStack** and add the **stack** parameter.

    ```lua
    [server only]
    void SendItemAddedEvent (ItemStack stack)
    {
        local event = SimpleInventoryItemAddedEvent()
        event.SlotIndex = stack.SlotIndex
        event.ItemId = stack.ItemId
        event.ItemCount = stack.Count
        self.Entity:SendEvent(event)
        
        -- Deliver to local players only
        self:SendItemAddedEventToClient(event, self.Entity.PlayerComponent.UserId)
    }
    ```
    
5. Create the new slot of the AddItem() function to call the SendItemAddedEvent() function under remain = remain - addCount in the Filling the remaining items paragraph. 

    ```lua        		
    self:SendItemAddedEvent(newStack)
    ```
    
# Changing Item Data
1. Create the SendItemModifiedEventToClient() function. Set the parameter type to **EventType - SimpleInventoryItemModifiedEvent** and add the **event** parameter.

    ```lua
    [client]
    void SendItemModifiedEventToClient (SimpleInventoryItemModifiedEvent event)
    {
        ---@type ItemStack
        local stack = self.ItemStacks[event.SlotIndex]
        stack.SlotIndex = event.SlotIndex
        stack.ItemId = event.ItemId
        stack.Count = event.ItemCount
        
        self.Entity:SendEvent(event)
    }
    ```

2. Add a SendItemModifiedEvent() function. Set the parameter type to **StructType - ItemStack** and add the **stack** parameter.
Write to trigger the SimpleInventoryItemModifiedEvent, an item change event.

    ```lua
    [server only]
    void SendItemModifiedEvent (ItemStack stack)
    {
        local event = SimpleInventoryItemModifiedEvent()
        event.SlotIndex = stack.SlotIndex
        event.ItemId = stack.ItemId
        event.ItemCount = stack.Count
        self.Entity:SendEvent(event)
        
        -- Deliver to local players only
        self:SendItemModifiedEventToClient(event, self.Entity.PlayerComponent.UserId)
    }
    ```

3.  Call the SendItemModifiedEvent() function under the remain = remain - addCount of the Filling the Remaining Items Paragraph of an existing slot for the AddItem() function. 

    ```lua
     self:SendItemModifiedEvent(stack)
    ```

4. Create the new HasSpaceFor() function and add the **itemId** and **itemCount** parameters. Write the following to check whether the item corresponding to the itemId can be contained in the inventory by itemCount.

    ```lua
    [server only]
    boolean HasSpaceFor (string itemId, integer itemCount)
    {
        local itemInfo = _Data.ItemTable[itemId]
        
        if itemInfo == nil then
        	log_error("[SimpleInventory] (HasSpaceFor) Item Id Error: " .. itemId)
        	return
        end
        
        if itemCount <= 0 then
        	log_error("[SimpleInventory] (HasSpaceFor) Item Count Error: " .. itemCount)
        	return
        end
        
        local maxStackCount = itemInfo.MaxStackCount
        local remain = itemCount
        
        for i = 1, self.Capacity do
        	if remain <= 0 then
        		break
        	end
        	
        	---@type ItemStack
        	local stack = self.ItemStacks[i]
        	
        	if stack == nil then
        		remain = remain - maxStackCount
        	elseif stack.ItemId == itemId then
        		remain = remain - math.min(maxStackCount - stack.Count, remain)
        	end
        end
        
        return (remain <= 0)
    }
    ```


# Removing an Item
1. Add a SendItemRemovedEventToClient() function. 

    ```lua
    [client]
    void SendItemRemovedEventToClient (SimpleInventoryItemRemovedEvent event)
    {
        self.ItemStacks[event.SlotIndex] = nil
        
        self.Entity:SendEvent(event)
    }
    ```

2. Add a SendItemRemovedEvent() function. Add an ItemsStack-type **stack** parameter.

    ```lua
    [server only]
    void SendItemRemovedEvent (ItemStack stack)
    {
        local event = SimpleInventoryItemRemovedEvent()
        event.SlotIndex = stack.SlotIndex
        event.ItemId = stack.ItemId
        self.Entity:SendEvent(event)
        
        -- Deliver to local players only
        self:SendItemRemovedEventToClient(event, self.Entity.PlayerComponent.UserId)
    }
    ```

3. Create the RemoveItemAt() function and add **slotIndex and itemCount** parameters. 
This function removes items from a specific slot. Write the following to decrease the number of items in the slot corresponding to the **slotIndex** by **itemCount**.

    * If an item still exists after removal, trigger the `SimpleInventoryItemRemovedEvent` event from the `SendItemRemovedEvent()`.
    * When all items are removed, trigger the item removal event, SimpleInventoryItemRemovedEvent.
    * It must return true if the item removal succeeds and false if it fails.

    ```lua
    [server only]
    boolean RemoveItemAt (integer slotIndex, integer itemCount)
    {
        if slotIndex < 1 or slotIndex > self.Capacity then
        	log_error("[SimpleInventory] (RemoveItemAt) Slot Index Error: " .. slotIndex)
        	return false
        end
        
        if itemCount < 1 then
        	log_error("[SimpleInventory] (RemoveItemAt) Item Count Error: " .. itemCount)
        	return false
        end
        
        ---@type ItemStack
        local stack = self.ItemStacks[slotIndex]
        
        if stack == nil then
        	log_error("[SimpleInventory] (RemoveItemAt) There is no item in the slot.")
        	return false
        end
        
        if stack.Count < itemCount then
        	log_error("[SimpleInventory] (RemoveItemAt) There aren't enough items.")
        	return false
        end
        
        stack.Count -= itemCount
        
        if stack.Count > 0 then
        	self:SendItemModifiedEvent(stack)
        else
        	self.ItemStacks[slotIndex] = nil
        	self:SendItemRemovedEvent(stack)
        end
        
        return true
    }
    ```

# Changing Meso Data
1. Add a SendMesoModifiedEventToClient() function.

    ```lua
    [client]
    void SendMesoModifiedEventToClient (SimpleInventoryMesoModifiedEvent event)
    {
        self.Meso = event.Meso
        
        self.Entity:SendEvent(event)
    }
    ```

2. Add a SendMesoModifiedEvent() function.

    ```lua
    [server only]
    void SendMesoModifiedEvent (integer meso)
    {
        local event = SimpleInventoryMesoModifiedEvent()
        event.Meso = meso
        self.Entity:SendEvent(event)
        
        -- Deliver to local players only
        self:SendMesoModifiedEventToClient(event, self.Entity.PlayerComponent.UserId)
    }
    ```

3. Add the SetMeso() function and add the **meso** parameter.

    ```lua
    [server only]
    void SetMeso (integer meso)
    {
        self.Meso = meso
        self:SendMesoModifiedEvent(meso)
    }
    ```
    

# Full Script
#### SimpleInventory

```lua
Property:
[None]
integer Meso = 10000
[None]
table ItemStacks = {}
[None]
integer Capacity = 16

Method:
[server only]
void OnBeginPlay()
{    
    -- Loading inventory data from the data storage
    local userId = self.Entity.PlayerComponent.UserId
    local userDataStorage = _DataStorageService:GetUserDataStorage(userId)
    local errorCode, loadData = userDataStorage:GetAndWait("SimpleInventoryData")
    
    -- Output error code if data load fails
    if errorCode ~= 0 then
    	log_error("[SimpleInventory] Data load fails:" .. tostring(errorCode))
    	return
    end
    
    -- If there is loaded data, apply it
    if loadData ~= nil then
    	self:Deserialize(loadData)
    end
    
    -- Inventory initialization event occurs
    self:SendInitializedEvent()
    
    -- Automatically save at regular intervals
    local saveInventory = function()
    	local saveData = self:Serialize()
    	UserDataStorage:SetAsync("SimpleInventoryData", saveData, function() log ("[SimpleInventory] Saved") end)
    	log ("[SimpleInventory] Saving...")
    end
    
    local saveInterval = 300
    _TimerService:SetTimerRepeat(saveInventory, saveInterval, saveInterval)
}
    
string Serialize()
{
    local dataTable = {}
    local itemStacks = {}
    
    dataTable.Meso = self.Meso
    
    for _, stack in pairs(self.ItemStacks) do
    	local stackData = stack:ToTable()
    	table.insert(itemStacks, stackData)
    end
    
    if #itemStacks > 0 then
    	dataTable.ItemStacks = itemStacks
    end
    
    return _HttpService:JSONEncode(dataTable)
}

void Deserialize (string dataString)
{
    if dataString == nil or dataString == "" then
    	return
    end
    
    local dataTable = _HttpService:JSONDecode(dataString)
    local meso = dataTable.Meso
    local stacks = dataTable.ItemStacks
    
    self.Meso = math.tointeger(meso)
    
    if stacks ~= nil then
    	for _, stackData in pairs(stacks) do
    		local stack = ItemStack()
    		stack:FromTable(stackData)
    		self.ItemStacks[stack.SlotIndex] = stack
    	end
    end
}

[server only]
integer AddItem (string itemId, integer itemCount)
{
    local itemInfo = _Data.ItemTable[itemId]
    
    if itemInfo == nil then
    	log_error("[SimpleInventory] (AddItem) Item Id Error: " .. itemId)
    	return
    end
    
    if itemCount <= 0 then
    	log_error("[SimpleInventory] (AddItem) Item Count Error: " .. itemCount)
    	return
    end
    
    local maxStackCount = itemInfo.MaxStackCount
    local remain = itemCount
    
    -- Fill in an existing slot
    for i = 1, self.Capacity do
        if remain <= 0 then
            break
        end
    
    ---@type ItemStack
    local stack = self.ItemStacks[i]
    
    if stack == nil then
        continue
    end
    
        if stack.ItemId == itemId then
            local addCount = math.min(maxStackCount - stack.Count, remain)
            stack.Count = stack.Count + addCount
            remain = remain - addCount
    
            self:SendItemModifiedEvent(stack)
        end
    end
    
    -- Create the new slot to fill in the remaining
    for i = 1, self.Capacity do
    if remain <= 0 then
        break
    end

    if self.ItemStacks[i] ~= nil then
        continue
    end
    
    local addCount = math.min(maxStackCount, remain)
    
    local newStack = ItemStack()
    newStack.SlotIndex = i
    newStack.ItemId = itemId
    newStack.Count = addCount
    self.ItemStacks[i] = newStack
    
    remain = remain - addCount
    
    self:SendItemAddedEvent(newStack)
    end
    
    -- Fill all and return the remaining count
    return remain
}

[server only]
boolean HasSpaceFor (string itemId, integer itemCount)
{
    local itemInfo = _Data.ItemTable[itemId]

    if itemInfo == nil then
    	log_error("[SimpleInventory] (HasSpaceFor) Item Id Error: " .. itemId)
    	return
    end

    if itemCount <= 0 then
    	log_error("[SimpleInventory] (HasSpaceFor) Item Count Error: " .. itemCount)
    	return
    end

    local maxStackCount = itemInfo.MaxStackCount
    local remain = itemCount

    for i = 1, self.Capacity do
    	if remain <= 0 then
    		break
    	end

    	---@type ItemStack
    	local stack = self.ItemStacks[i]

    	if stack == nil then
    		remain = remain - maxStackCount
    	elseif stack.ItemId == itemId then
    		remain = remain - math.min(maxStackCount - stack.Count, remain)
    	end
    end

    return (remain <= 0)
}


[server only]
boolean RemoveItemAt (integer slotIndex, integer itemCount)
{
    if slotIndex < 1 or slotIndex > self.Capacity then
    	log_error("[SimpleInventory] (RemoveItemAt) Slot Index Error: " .. slotIndex)
    	return false
    end

    if itemCount < 1 then
    	log_error("[SimpleInventory] (RemoveItemAt) Item Count Error: " .. itemCount)
    	return false
    end

    ---@type ItemStack
    local stack = self.ItemStacks[slotIndex]

    if stack == nil then
    	log_error("[SimpleInventory] (RemoveItemAt) There is no item in the slot.")
    	return false
    end

    if stack.Count < itemCount then
    	log_error("[SimpleInventory] (RemoveItemAt) There aren't enough items.")
    	return false
    end

    stack.Count -= itemCount

    if stack.Count > 0 then
    	self:SendItemModifiedEvent(stack)
    else
    	self.ItemStacks[slotIndex] = nil
    	self:SendItemRemovedEvent(stack)
    end

    return true
}

[server only]
void SetMeso (integer meso)
{
    self.Meso = meso
    self:SendMesoModifiedEvent(meso)
}

[server only]
void SendInitializedEvent()
{
    local event = SimpleInventoryInitializedEvent()
    event.Meso = self.Meso
    event.ItemStacks = self.ItemStacks
    self.Entity:SendEvent(event)
    
    -- Deliver to local players only
    self:SendInitializedEventToClient(event, self.Entity.PlayerComponent.UserId)
}

[client]
void SendInitializedEventToClient (SimpleInventoryInitializedEvent event)
{
    self.Meso = event.Meso
    self.ItemStacks = event.ItemStacks
    self.Entity:SendEvent(event)
}

[server only]
void SendItemAddedEvent(ItemStack stack)
{
    local event = SimpleInventoryItemAddedEvent()
    event.SlotIndex = stack.SlotIndex
    event.ItemId = stack.ItemId
    event.ItemCount = stack.Count
    self.Entity:SendEvent(event)
    
    -- Deliver to local players only
    self:SendItemAddedEventToClient(event, self.Entity.PlayerComponent.UserId)
}

[client]
void SendItemAddedEventToClient (SimpleInventoryItemAddedEvent event)
{
    local stack = ItemStack()
    stack.SlotIndex = event.SlotIndex
    stack.ItemId = event.ItemId
    stack.Count = event.ItemCount
    self.ItemStacks[event.SlotIndex] = stack
    
    self.Entity:SendEvent(event)
}

[server only]
void SendItemModifiedEvent (ItemStack stack)
{
    local event = SimpleInventoryItemModifiedEvent()
    event.SlotIndex = stack.SlotIndex
    event.ItemId = stack.ItemId
    event.ItemCount = stack.Count
    self.Entity:SendEvent(event)

    -- Deliver to local players only
    self:SendItemModifiedEventToClient(event, self.Entity.PlayerComponent.UserId)
}

[Client]
void SendItemModifiedEventToClient (SimpleInventoryItemModifiedEvent event)
{
    ---@type ItemStack
    local stack = self.ItemStacks[event.SlotIndex]
    stack.SlotIndex = event.SlotIndex
    stack.ItemId = event.ItemId
    stack.Count = event.ItemCount
    
    self.Entity:SendEvent(event)
}


[server only]
void SendMesoModifiedEvent (integer meso)
{
    local event = SimpleInventoryMesoModifiedEvent()
    event.Meso = meso
    self.Entity:SendEvent(event)

    -- Deliver to local players only
    self:SendMesoModifiedEventToClient(event, self.Entity.PlayerComponent.UserId)
}

[client]
void SendMesoModifiedEventToClient (SimpleInventoryMesoModifiedEvent event)
{
    self.Meso = event.Meso
    
    self.Entity:SendEvent(event)    
}

[server only]
void SendItemRemovedEvent (ItemStack stack)
{
    local event = SimpleInventoryItemRemovedEvent()
    event.SlotIndex = stack.SlotIndex
    event.ItemId = stack.ItemId
    self.Entity:SendEvent(event)

    -- Deliver to local players only
    self:SendItemRemovedEventToClient(event, self.Entity.PlayerComponent.UserId)
}

[client]
void SendItemRemovedEventToClient (SimpleInventoryItemRemovedEvent event)
{
    self.ItemStacks[event.SlotIndex] = nil
    
    self.Entity:SendEvent(event)
}

Entity Event Handler:
[service: UserService]
HandleUserLeaveEvent (UserLeaveEvent event)
{
    --------------- Native Event Sender Info ----------------
    -- Sender: UserService
    -- Space: Server
    ---------------------------------------------------------
    
    -- Parameters
    local UserId = event.UserId
    ---------------------------------------------------------
    
    local thisUserId = self.Entity.PlayerComponent.UserId
    
    if thisUserId ~= UserId then
    	return
    end
    
    -- Save inventory data info when play is over
    local userDataStorage = _DataStorageService:GetUserDataStorage(thisUserId)
    if userDataStorage ~= nil then
    	local saveData = self:Serialize()
    	userDataStorage:SetAndWait("SimpleInventoryData", saveData)
    end
} 
```


#### SimpleInventoryItemAddedEvent
```lua
Property:
integer SlotIndex = 0
string ItemId = ""
integer ItemCount = 0
```


#### SimpleInventoryItemModifiedEvent
```lua
Property:
integer SlotIndex = 0
string ItemId = ""
integer ItemCount = 0
```

#### SimpleInventoryItemRemovedEvent
```lua
Property:
integer SlotIndex = 0
string ItemId = ""
```

#### SimpleInventoryMesoModifiedEvent
```lua
Property:
integer Meso = 0
```